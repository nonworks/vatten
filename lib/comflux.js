// Generated by CoffeeScript 1.10.0
(function() {
  var Comflux, Flow;

  Flow = require('./flow');

  module.exports = Comflux = function() {
    var bind, clone, component, fill, fillByGoingToBottom, fillByGoingToTop, getConstraint, getName, indices, match, spoutByName, spouts, updateIndex;
    component = Flow();
    spouts = [];
    indices = {};
    spoutByName = {};
    component.add = function(spout, opts) {
      var constraint, entry, j, len, name, s, targetSpout;
      if (opts == null) {
        opts = {};
      }
      name = getName(spout, opts);
      constraint = getConstraint(name, opts.on, opts.optional);
      if (constraint) {
        targetSpout = null;
        for (j = 0, len = spouts.length; j < len; j++) {
          s = spouts[j];
          if (s.name === constraint.target.name) {
            targetSpout = s;
            break;
          }
        }
        if (!targetSpout) {
          throw "No source for " + constraint.target.name + ", did you add it?";
        }
        component.addIndex(constraint.target.name, constraint.target.key);
        component.addIndex(constraint.source.name, constraint.source.key);
      }
      entry = {
        spout: spout,
        name: name,
        constraint: constraint
      };
      spouts.push(entry);
      spoutByName[name] = entry;
      return bind(spout, name);
    };
    component.addIndex = function(spout, key) {
      var base;
      indices[spout] || (indices[spout] = {});
      return (base = indices[spout])[key] || (base[key] = {});
    };
    component.get = function(spout, key, val) {
      var k, m, s, v;
      s = indices[spout] || (function() {
        throw "No such spout " + spout;
      })();
      k = s[key] || (function() {
        throw "No such key " + key;
      })();
      v = k[val];
      if (v) {
        m = match(spout, v);
        if (m && m.isDeleted) {
          return null;
        } else {
          return m;
        }
      }
    };
    component.dumpScheme = function() {
      var constraint, j, len, name, ref, results, spout;
      results = [];
      for (j = 0, len = spouts.length; j < len; j++) {
        ref = spouts[j], spout = ref.spout, name = ref.name, constraint = ref.constraint;
        results.push(console.log(name, constraint));
      }
      return results;
    };
    getName = function(spout, opts) {
      var name;
      return name = opts.as || spout.name || (function() {
        throw 'Unnamed flow and no `as` option';
      })();
    };
    getConstraint = function(name, onStr, optional) {
      var r;
      if (onStr) {
        r = onStr.match(/(\w+)\s*=\s*(\w+)\.(\w+)/);
        if (!r) {
          throw "Could not match the string " + onStr + ", should be {key} = {spout}.{key}";
        }
        return {
          source: {
            name: name,
            key: r[1],
            optional: optional
          },
          target: {
            name: r[2],
            key: r[3]
          }
        };
      }
    };
    bind = function(spout, name) {
      return spout.on('drip', function(data) {
        updateIndex(name, data);
        return match(name, data);
      });
    };
    updateIndex = function(name, data) {
      var i, k, name1, results, v;
      if (i = indices[name]) {
        results = [];
        for (k in i) {
          v = i[k];
          results.push((v[name1 = data[k]] || (v[name1] = [])).push(data));
        }
        return results;
      }
    };
    match = function(name, data) {
      var obj1;
      return fill((
        obj1 = {},
        obj1["" + name] = data,
        obj1
      ), function(matches) {
        var j, k, len, s, v;
        matches.id = matches[spouts[0].name].id;
        for (j = 0, len = spouts.length; j < len; j++) {
          s = spouts[j];
          k = s.name;
          v = matches[k];
          if (v === true) {
            delete matches[k];
            continue;
          }
          if (v.isDeleted) {
            matches.isDeleted = true;
            break;
          }
        }
        return component.trigger('drip', matches);
      });
    };
    clone = function(obj) {
      var k, out, v;
      out = {};
      for (k in obj) {
        v = obj[k];
        out[k] = v;
      }
      return out;
    };
    fill = function(startMatches, cb) {
      return fillByGoingToTop(startMatches, function(partialMatches) {
        return fillByGoingToBottom(partialMatches, function(matches) {
          return cb(matches);
        });
      });
    };
    fillByGoingToTop = function(matches, cb) {
      var hit, hits, j, l, len, len1, newMatches, results, s, source, sourceValue, target;
      if (matches[spouts[0].name]) {
        cb(matches);
        return;
      }
      source = null;
      for (j = 0, len = spouts.length; j < len; j++) {
        s = spouts[j];
        if (matches[s.name]) {
          source = s;
          break;
        }
      }
      target = spoutByName[source.constraint.target.name];
      sourceValue = matches[source.name][source.constraint.source.key];
      hits = indices[target.name][source.constraint.target.key][sourceValue];
      if (!hits) {
        if (source.constraint.source.optional) {
          matches[target.name] = true;
          return fillByGoingToTop(matches, cb);
        }
      } else {
        results = [];
        for (l = 0, len1 = hits.length; l < len1; l++) {
          hit = hits[l];
          newMatches = clone(matches);
          newMatches[target.name] = hit;
          results.push(fillByGoingToTop(newMatches, cb));
        }
        return results;
      }
    };
    fillByGoingToBottom = function(matches, cb) {
      var hit, hits, j, l, len, len1, newMatches, results, s, source, targetValue;
      source = null;
      for (j = 0, len = spouts.length; j < len; j++) {
        s = spouts[j];
        if (!matches[s.name]) {
          source = s;
          break;
        }
      }
      if (!source) {
        cb(matches);
        return;
      }
      targetValue = matches[source.constraint.target.name][source.constraint.target.key];
      hits = indices[source.constraint.source.name][source.constraint.source.key][targetValue];
      if (!hits) {
        if (source.constraint.source.optional) {
          matches[source.name] = true;
          return fillByGoingToBottom(matches, cb);
        }
      } else {
        results = [];
        for (l = 0, len1 = hits.length; l < len1; l++) {
          hit = hits[l];
          newMatches = clone(matches);
          newMatches[source.name] = hit;
          results.push(fillByGoingToBottom(newMatches, cb));
        }
        return results;
      }
    };
    return component;
  };

}).call(this);
